# RLS & Storage Audit Checklist (Supabase / Postgres)

## Purpose
This checklist is used to **audit, review and stabilize** Row Level Security (RLS)
and Supabase Storage policies.

It is designed to **prevent assumption-based security**, trial/error policies
and long-term security debt.

Run this checklist:
- after schema changes
- after RLS or Storage policy changes
- before releases
- periodically (e.g. monthly)

---

## 1. Mental Model Check (Mandatory)

- [ ] Is the **ownership model** explicitly defined?
  - owner-only
  - shared (future)
  - public (explicit)

- [ ] Is the **database the source of truth** for permissions?
- [ ] Does the client have **zero authority** over access decisions?

If any answer is unclear → **stop and clarify first**.

---

## 2. RLS Fundamentals (Database Tables)

### Enablement
- [ ] RLS enabled on **every table**
- [ ] No table unintentionally left open

```sql
alter table <table> enable row level security;
```

---

### Policy Shape (Critical)
For owner-only tables, policies must:
- [ ] use `auth.uid()`
- [ ] reference ownership via a **parent table**
- [ ] avoid joins across multiple unrelated tables
- [ ] avoid `auth.jwt()` unless absolutely required

Preferred pattern:
```sql
exists (
  select 1
  from projects p
  where p.id = project_id
    and p.owner_id = auth.uid()
)
```

---

### USING vs WITH CHECK
- [ ] `USING` defined for select/update/delete
- [ ] `WITH CHECK` defined for insert/update
- [ ] No policy missing `WITH CHECK`

Missing `WITH CHECK` = silent privilege escalation risk.

---

## 3. RLS Consistency Audit

- [ ] All child tables use **identical ownership logic**
- [ ] No policy re-implements ownership differently
- [ ] No shortcuts or special cases

Tip:
> Copy-paste ownership logic. Do not “optimize” it.

---

## 4. Storage Policy Audit (Supabase Storage)

### Bucket Scope
- [ ] `bucket_id` explicitly checked
- [ ] No wildcard bucket access

```sql
bucket_id = 'project_images'
```

---

### Path Semantics (Critical)
- [ ] Folder structure is **explicit and enforced**
- [ ] No assumptions about filename contents
- [ ] All path indices documented

Example:
```sql
(storage.foldername(name))[1] = 'projects'
(storage.foldername(name))[2] = <project_id>
(storage.foldername(name))[3] in ('master','working')
```

Document what each index means.

---

### Ownership Verification
- [ ] Storage policies verify ownership via DB
- [ ] `project_id` extracted from path is validated
- [ ] No trust in client-provided metadata

```sql
exists (
  select 1 from projects p
  where p.id::text = (storage.foldername(name))[2]
    and p.owner_id = auth.uid()
)
```

---

## 5. CRUD Coverage Check

For **every protected table or bucket**:
- [ ] SELECT policy exists
- [ ] INSERT policy exists
- [ ] UPDATE policy exists
- [ ] DELETE policy exists

Missing one = inconsistent behavior.

---

## 6. Duplication vs Safety (Important)

- [ ] Policy logic may be duplicated intentionally
- [ ] Duplication is documented as **mirrored logic**
- [ ] No attempt to prematurely DRY security logic

Rule:
> Security duplication is safer than abstraction.

---

## 7. Migration Safety

- [ ] Schema changes reviewed for RLS impact
- [ ] Column renames checked against policies
- [ ] Path conventions never changed silently
- [ ] Old policies removed explicitly

Never assume migrations are RLS-neutral.

---

## 8. Negative Case Testing (Mandatory)

Explicitly test:
- [ ] User cannot access another user’s data
- [ ] User cannot guess IDs
- [ ] User cannot upload to foreign paths
- [ ] User cannot modify metadata to escalate privileges

If a test is not run, assume it fails.

---

## 9. Future-Proofing (Sharing, Links, Reviewers)

Before adding:
- shared projects
- reviewer links
- public access

Ask:
- [ ] Will this be a **new policy layer**, not an extension?
- [ ] Are existing owner-only policies left untouched?
- [ ] Is privilege separation explicit?

Never “extend” owner-only policies.

---

## 10. Final Gate

Before shipping:
- [ ] All assumptions written down
- [ ] Policies reviewed without UI context
- [ ] RLS works independently of frontend logic
- [ ] Storage access impossible without DB authorization

---

## Core Rule

> RLS and Storage policies must be **boring, repetitive and explicit**.
> If a policy feels clever, it is probably wrong.
